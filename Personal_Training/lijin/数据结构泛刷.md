【数据结构泛刷】



【1】



1.http://codeforces.com/problemset/problem/19/D

注：线段树维护一组set中最大值的变化，查询>=pos下标中值>=x的最小下标，在指定set中进一步维护或者查询



2.http://codeforces.com/problemset/problem/1140/F

注：经典的线段树分治，提取每个插入操作的存活周期，抹除删除操作

线段树标记永久化思想(一个周期分成log段)，在线段树上dfs，递归时执行插入操作，回溯时撤销

使用可撤销并查集(按秩启发式合并)，在叶节点状态回答询问

维护答案：刚开始每个横坐标和纵坐标单独一个集合，每个集合维护其中横纵坐标个数；

插入一条边，即可能合并两个集合，对答案贡献为numx[p]*numy[q] + numy[p]*numx[p]

注意撤销时的操作顺序，不要忘了维护并查集结构



3.http://codeforces.com/problemset/problem/13/E

注：简单分块+并查集，也可以用lct(注意模板中rev标记不能删除)


4.http://codeforces.com/problemset/problem/580/E

注：线段树区间替换，区间查询hash值



5.http://codeforces.com/problemset/problem/484/E

注：二分+可持久化线段树，离线从大到小插入权值，维护01串，查询区间最长"1"段的长度，典型的三段论线段树

特别注意：merge函数，不要把参数设置成const node &p形式，让其自然的拷贝，

避免x=merge(x,y)中x自更新不完全导致的错误



6.http://codeforces.com/problemset/problem/557/E

注：经典的01字典树上求k大值问题，形式类似于：问给定01串中所有子串字典序k大的子串，O(n^2)



7.http://codeforces.com/problemset/problem/710/F

**注**：经典的强制在线ac自动机，维护一个字符串集合，支持动态插入串，动态删除串，在线查询给定串在集合中子串数目

**消除动态删除**：维护两个ac自动机森林in和out，插入串插入到in，删除串插入到out，因为此种数目满足减法性质，分别查询相减即可(代价为一个2)

**消除在线插入**：ac自动机不可在线插入串，采用二进制分组算法，在线转离线，每次插入一个串，新建一个ac自动机，阶为1，如果与上一个ac自动机阶相同，就合并到上一个，暴力重构合并之后的自动机fail树和维护的相关信息(每个串最多合并log次)，此步本质上是一种离线做法(代价为一个log)

**在线查询**：在森林中每个自动机上分别查询，叠加即可；ac自动机查询是在线的

**技巧与注意点**：

1)0号点设立为森林中所有点共用的超级虚拟节点，每个自动机空串节点插入时再自己维护

2)设S=rt[k]为第k个自动机的根，也是当前要操作的根节点，千万注意在插入完之后的构建build过程和对每个自动机的查询过程中，都要初始化一下此自动机：将0号点的每一个转移都设为S，即：go[0][c]=S

3)特别注意不要构造trie图，保留节点的每个空转移

**关于ac自动机的合并**

1)本质是DAG的合并

2)注意合并的时候，不要忘记合并节点的标记，考虑标记合并时到底是或还是加的关系，也有可能是多规则合并

**本题其他参考做法**：

1)二进制分组+后缀自动机，思路类似

2)采用分类算法，对串长设立阈值，长一点的暴力插入ac自动机中并维护，短一点的存起来暴力kmp匹配，速度较快

3)字符串hash：用到基本思想，总串长为一定规模的若干字符串，其长度种类不超过根号种

对每种长度利用一个set维护插入串的hash值，查询时扫描所有不同长度种类，再扫描此种长度的所有子串，去指定set中查询此子串hash值是否存在，其总复杂度暂不明晰





8.http://codeforces.com/problemset/problem/1083/C

注：线段树合并式dp，一个节点[l,r]存储树上包含此闭区间数值的最小链端点对，此信息可单点修改，合并维护

查询最小非法前缀，查询时，带一个动态修改的查询参数，表示当前区间[l,r]严格前面的区间[0,l-1]的信息并

查询时，左子树不可并，递归去左子树，否则右子树；叶节点特判是否符合







9.http://codeforces.com/problemset/problem/407/E

注：线段树+单调栈，对于时刻i，只考虑前i个元素，线段树维护数列p[j]=max(a[j]..a[i])-min(a[j]..a[i])+i

注意到max(a[j]..a[i])关于j单调，画图分析(函数值分布是分段的，且段右端点单调，可用单调栈维护)，

当多考虑a[i]这个元素时，状态变化，从单调栈中弹出的元素，须在线段树中在所支配的区间更新叠加一个增量

从左到右穷举右端点i，线段树查询使得p[j]<=i+K的一个最小下标，即左端点j

技巧：由于有其他的限制条件，线段树上查询的区间本质上不是一个前缀，而是一个个不交的段，可将不在查询区间的部分叠加上+oo，使其无解





10.http://codeforces.com/problemset/problem/1004/F

注：线段树+双指针+容斥，线段树单点替换，区间求和(维护node合并，经典的线段树三段论)

考虑函数h(j)=OR(a[i]..a[j])关于j段状递增(最多log段)，维护每个线段树节点区间的前后缀(保存段信息)，若pos(i)表示左端点为i时的最远右端点段标使得区间不满足条件，易知容斥之，使得区间具有区间包含单调性(即[l,r]不满足题意，这子区间亦不满足)，这导出pos(i)关于i不降，结合段状特性，使得使用双指针只需log扫描代价即可轻松合并

段状表示，左子区间以段左端点为关键点，右子区间以段的右端点为关键点，且均添加0号元素，这使得合并时计算答案很容易

特别注意：更新段状表示(即节点的l[24],r[24])时，注意考虑新加入若干元素，如果不能更新段末的值，也要更新段下标，使其符合精确定义










